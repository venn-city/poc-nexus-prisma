"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var args_1 = require("./definitions/args");
var definitionBlocks_1 = require("./definitions/definitionBlocks");
var interfaceType_1 = require("./definitions/interfaceType");
var objectType_1 = require("./definitions/objectType");
var unionType_1 = require("./definitions/unionType");
var wrapping_1 = require("./definitions/wrapping");
var typegenMetadata_1 = require("./typegenMetadata");
var utils_1 = require("./utils");
var SCALARS = {
    String: graphql_1.GraphQLString,
    Int: graphql_1.GraphQLInt,
    Float: graphql_1.GraphQLFloat,
    ID: graphql_1.GraphQLID,
    Boolean: graphql_1.GraphQLBoolean,
};
/**
 * Builds all of the types, properly accounts for any using "mix".
 * Since the enum types are resolved synchronously, these need to guard for
 * circular references at this step, while fields will guard for it during lazy evaluation.
 */
var SchemaBuilder = /** @class */ (function () {
    function SchemaBuilder(config) {
        this.config = config;
        /**
         * Used to check for circular references.
         */
        this.buildingTypes = new Set();
        /**
         * The "final type" map contains all types as they are built.
         */
        this.finalTypeMap = {};
        /**
         * The "defined type" map keeps track of all of the types that were
         * defined directly as `GraphQL*Type` objects, so we don't accidentally
         * overwrite any.
         */
        this.definedTypeMap = {};
        /**
         * The "pending type" map keeps track of all types that were defined w/
         * GraphQL Nexus and haven't been processed into concrete types yet.
         */
        this.pendingTypeMap = {};
        /**
         * All "extensions" to types (adding fields on types from many locations)
         */
        this.typeExtensionMap = {};
        /**
         * All "extensions" to input types (adding fields on types from many locations)
         */
        this.inputTypeExtensionMap = {};
        /**
         * Configures the root-level nonNullDefaults defaults
         */
        this.nonNullDefaults = {};
        /**
         * Add dynamic input fields
         */
        this.dynamicInputFields = {};
        /**
         * Add dynamic output fields
         */
        this.dynamicOutputFields = {};
        /**
         * All types that need to be traversed for children types
         */
        this.typesToWalk = [];
        /**
         * Root type mapping information annotated on the type definitions
         */
        this.rootTypings = {};
        /**
         * Whether we've called `getFinalTypeMap` or not
         */
        this.finalized = false;
        this.nonNullDefaults = tslib_1.__assign({ input: false, output: true }, config.nonNullDefaults);
    }
    SchemaBuilder.prototype.getConfig = function () {
        return this.config;
    };
    /**
     * Add type takes a Nexus type, or a GraphQL type and pulls
     * it into an internal "type registry". It also does an initial pass
     * on any types that are referenced on the "types" field and pulls
     * those in too, so you can define types anonymously, without
     * exporting them.
     *
     * @param typeDef
     */
    SchemaBuilder.prototype.addType = function (typeDef) {
        if (wrapping_1.isNexusDynamicInputMethod(typeDef)) {
            this.dynamicInputFields[typeDef.name] = typeDef;
            return;
        }
        if (wrapping_1.isNexusDynamicOutputMethod(typeDef)) {
            this.dynamicOutputFields[typeDef.name] = typeDef;
            return;
        }
        var existingType = this.finalTypeMap[typeDef.name] || this.pendingTypeMap[typeDef.name];
        if (wrapping_1.isNexusExtendTypeDef(typeDef)) {
            var typeExtensions = (this.typeExtensionMap[typeDef.name] =
                this.typeExtensionMap[typeDef.name] || []);
            typeExtensions.push(typeDef.value);
            this.typesToWalk.push({ type: "object", value: typeDef.value });
            return;
        }
        if (wrapping_1.isNexusExtendInputTypeDef(typeDef)) {
            var typeExtensions = (this.inputTypeExtensionMap[typeDef.name] =
                this.inputTypeExtensionMap[typeDef.name] || []);
            typeExtensions.push(typeDef.value);
            this.typesToWalk.push({ type: "input", value: typeDef.value });
            return;
        }
        if (existingType) {
            // Allow importing the same exact type more than once.
            if (existingType === typeDef) {
                return;
            }
            throw extendError(typeDef.name);
        }
        if (wrapping_1.isNexusScalarTypeDef(typeDef) && typeDef.value.asNexusMethod) {
            this.dynamicInputFields[typeDef.value.asNexusMethod] = typeDef.name;
            this.dynamicOutputFields[typeDef.value.asNexusMethod] = typeDef.name;
            if (typeDef.value.rootTyping) {
                this.rootTypings[typeDef.name] = typeDef.value.rootTyping;
            }
        }
        else if (graphql_1.isScalarType(typeDef)) {
            var scalarDef = typeDef;
            if (scalarDef.extensions && scalarDef.extensions.nexus) {
                var _a = scalarDef.extensions.nexus, asNexusMethod = _a.asNexusMethod, rootTyping = _a.rootTyping;
                if (asNexusMethod) {
                    this.dynamicInputFields[asNexusMethod] = scalarDef.name;
                    this.dynamicOutputFields[asNexusMethod] = typeDef.name;
                }
                if (rootTyping) {
                    this.rootTypings[scalarDef.name] = rootTyping;
                }
            }
        }
        if (graphql_1.isNamedType(typeDef)) {
            this.finalTypeMap[typeDef.name] = typeDef;
            this.definedTypeMap[typeDef.name] = typeDef;
            this.typesToWalk.push({ type: "named", value: typeDef });
        }
        else {
            this.pendingTypeMap[typeDef.name] = typeDef;
        }
        if (wrapping_1.isNexusInputObjectTypeDef(typeDef)) {
            this.typesToWalk.push({ type: "input", value: typeDef.value });
        }
        if (wrapping_1.isNexusObjectTypeDef(typeDef)) {
            this.typesToWalk.push({ type: "object", value: typeDef.value });
        }
        if (wrapping_1.isNexusInterfaceTypeDef(typeDef)) {
            this.typesToWalk.push({ type: "interface", value: typeDef.value });
        }
    };
    SchemaBuilder.prototype.walkTypes = function () {
        var obj;
        while ((obj = this.typesToWalk.shift())) {
            switch (obj.type) {
                case "input":
                    this.walkInputType(obj.value);
                    break;
                case "interface":
                    this.walkInterfaceType(obj.value);
                    break;
                case "named":
                    this.walkNamedTypes(obj.value);
                    break;
                case "object":
                    this.walkOutputType(obj.value);
                    break;
            }
        }
    };
    SchemaBuilder.prototype.getFinalTypeMap = function () {
        var _this = this;
        this.finalized = true;
        this.walkTypes();
        // If Query isn't defined, set it to null so it falls through to "missingType"
        if (!this.pendingTypeMap.Query) {
            this.pendingTypeMap.Query = null;
        }
        Object.keys(this.pendingTypeMap).forEach(function (key) {
            // If we've already constructed the type by this point,
            // via circular dependency resolution don't worry about building it.
            if (_this.finalTypeMap[key]) {
                return;
            }
            if (_this.definedTypeMap[key]) {
                throw extendError(key);
            }
            _this.finalTypeMap[key] = _this.getOrBuildType(key);
            _this.buildingTypes.clear();
        });
        Object.keys(this.typeExtensionMap).forEach(function (key) {
            // If we haven't defined the type, assume it's an object type
            if (_this.typeExtensionMap[key] !== null) {
                _this.buildObjectType({
                    name: key,
                    definition: function () { },
                });
            }
        });
        Object.keys(this.inputTypeExtensionMap).forEach(function (key) {
            // If we haven't defined the type, assume it's an object type
            if (_this.inputTypeExtensionMap[key] !== null) {
                _this.buildInputObjectType({
                    name: key,
                    definition: function () { },
                });
            }
        });
        return {
            typeMap: this.finalTypeMap,
            dynamicFields: {
                dynamicInputFields: this.dynamicInputFields,
                dynamicOutputFields: this.dynamicOutputFields,
            },
            rootTypings: this.rootTypings,
        };
    };
    SchemaBuilder.prototype.buildInputObjectType = function (config) {
        var _this = this;
        var fields = [];
        var definitionBlock = new definitionBlocks_1.InputDefinitionBlock({
            typeName: config.name,
            addField: function (field) { return fields.push(field); },
            addDynamicInputFields: function (block, isList) {
                return _this.addDynamicInputFields(block, isList);
            },
        });
        config.definition(definitionBlock);
        var extensions = this.inputTypeExtensionMap[config.name];
        if (extensions) {
            extensions.forEach(function (extension) {
                extension.definition(definitionBlock);
            });
        }
        this.inputTypeExtensionMap[config.name] = null;
        return this.finalize(new graphql_1.GraphQLInputObjectType({
            name: config.name,
            fields: function () { return _this.buildInputObjectFields(fields, config); },
            description: config.description,
        }));
    };
    SchemaBuilder.prototype.buildObjectType = function (config) {
        var _this = this;
        var fields = [];
        var interfaces = [];
        var modifications = {};
        var definitionBlock = new objectType_1.ObjectDefinitionBlock({
            typeName: config.name,
            addField: function (fieldDef) { return fields.push(fieldDef); },
            addInterfaces: function (interfaceDefs) { return interfaces.push.apply(interfaces, interfaceDefs); },
            addFieldModifications: function (mods) {
                modifications[mods.field] = modifications[mods.field] || [];
                modifications[mods.field].push(mods);
            },
            addDynamicOutputFields: function (block, isList) {
                return _this.addDynamicOutputFields(block, isList);
            },
        });
        config.definition(definitionBlock);
        var extensions = this.typeExtensionMap[config.name];
        if (extensions) {
            extensions.forEach(function (extension) {
                extension.definition(definitionBlock);
            });
        }
        this.typeExtensionMap[config.name] = null;
        if (config.rootTyping) {
            this.rootTypings[config.name] = config.rootTyping;
        }
        return this.finalize(new graphql_1.GraphQLObjectType({
            name: config.name,
            interfaces: function () { return interfaces.map(function (i) { return _this.getInterface(i); }); },
            description: config.description,
            fields: function () {
                var allFieldsMap = {};
                var allInterfaces = interfaces.map(function (i) { return _this.getInterface(i); });
                allInterfaces.forEach(function (i) {
                    var interfaceFields = i.getFields();
                    // We need to take the interface fields and reconstruct them
                    // this actually simplifies things becuase if we've modified
                    // the field at all it needs to happen here.
                    Object.keys(interfaceFields).forEach(function (iFieldName) {
                        var _a = interfaceFields[iFieldName], isDeprecated = _a.isDeprecated, args = _a.args, rest = tslib_1.__rest(_a, ["isDeprecated", "args"]);
                        allFieldsMap[iFieldName] = tslib_1.__assign({}, rest, { args: args.reduce(function (result, a) {
                                var name = a.name, argRest = tslib_1.__rest(a, ["name"]);
                                result[name] = argRest;
                                return result;
                            }, {}) });
                        var mods = modifications[iFieldName];
                        if (mods) {
                            mods.map(function (mod) {
                                if (typeof mod.description !== "undefined") {
                                    allFieldsMap[iFieldName].description = mod.description;
                                }
                                if (typeof mod.resolve !== "undefined") {
                                    allFieldsMap[iFieldName].resolve = mod.resolve;
                                }
                            });
                        }
                    });
                });
                return _this.buildObjectFields(fields, config, allFieldsMap);
            },
        }));
    };
    SchemaBuilder.prototype.buildInterfaceType = function (config) {
        var _this = this;
        var name = config.name, description = config.description;
        var resolveType;
        var fields = [];
        var definitionBlock = new interfaceType_1.InterfaceDefinitionBlock({
            typeName: config.name,
            addField: function (field) { return fields.push(field); },
            setResolveType: function (fn) { return (resolveType = fn); },
            addDynamicOutputFields: function (block, isList) {
                return _this.addDynamicOutputFields(block, isList);
            },
        });
        config.definition(definitionBlock);
        var extensions = this.typeExtensionMap[config.name];
        if (extensions) {
            extensions.forEach(function (extension) {
                extension.definition(definitionBlock);
            });
        }
        if (!resolveType) {
            resolveType = this.missingResolveType(config.name, "union");
        }
        if (config.rootTyping) {
            this.rootTypings[config.name] = config.rootTyping;
        }
        return this.finalize(new graphql_1.GraphQLInterfaceType({
            name: name,
            fields: function () { return _this.buildObjectFields(fields, config, {}, true); },
            resolveType: resolveType,
            description: description,
        }));
    };
    SchemaBuilder.prototype.buildEnumType = function (config) {
        var members = config.members;
        var values = {};
        if (Array.isArray(members)) {
            members.forEach(function (m) {
                if (typeof m === "string") {
                    values[m] = { value: m };
                }
                else {
                    values[m.name] = {
                        value: typeof m.value === "undefined" ? m.name : m.value,
                        deprecationReason: m.deprecation,
                        description: m.description,
                    };
                }
            });
        }
        else {
            Object.keys(members)
                // members can potentially be a TypeScript enum.
                // The compiled version of this enum will be the members object,
                // numeric enums members also get a reverse mapping from enum values to enum names.
                // In these cases we have to ensure we don't include these reverse mapping keys.
                // See: https://www.typescriptlang.org/docs/handbook/enums.html
                .filter(function (key) { return isNaN(+key); })
                .forEach(function (key) {
                graphql_1.assertValidName(key);
                values[key] = {
                    value: members[key],
                };
            });
        }
        if (!Object.keys(values).length) {
            throw new Error("GraphQL Nexus: Enum " + config.name + " must have at least one member");
        }
        if (config.rootTyping) {
            this.rootTypings[config.name] = config.rootTyping;
        }
        return this.finalize(new graphql_1.GraphQLEnumType({
            name: config.name,
            values: values,
            description: config.description,
        }));
    };
    SchemaBuilder.prototype.buildUnionType = function (config) {
        var _this = this;
        var members;
        var resolveType;
        config.definition(new unionType_1.UnionDefinitionBlock({
            setResolveType: function (fn) { return (resolveType = fn); },
            addUnionMembers: function (unionMembers) { return (members = unionMembers); },
        }));
        if (!resolveType) {
            resolveType = this.missingResolveType(config.name, "union");
        }
        if (config.rootTyping) {
            this.rootTypings[config.name] = config.rootTyping;
        }
        return this.finalize(new graphql_1.GraphQLUnionType({
            name: config.name,
            resolveType: resolveType,
            description: config.description,
            types: function () { return _this.buildUnionMembers(config.name, members); },
        }));
    };
    SchemaBuilder.prototype.buildScalarType = function (config) {
        if (config.rootTyping) {
            this.rootTypings[config.name] = config.rootTyping;
        }
        return this.finalize(new graphql_1.GraphQLScalarType(config));
    };
    SchemaBuilder.prototype.finalize = function (type) {
        this.finalTypeMap[type.name] = type;
        return type;
    };
    SchemaBuilder.prototype.missingType = function (typeName, fromObject) {
        if (fromObject === void 0) { fromObject = false; }
        invariantGuard(typeName);
        if (typeName === "Query") {
            return new graphql_1.GraphQLObjectType({
                name: "Query",
                fields: {
                    ok: {
                        type: graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
                        resolve: function () { return true; },
                    },
                },
            });
        }
        var suggestions = utils_1.suggestionList(typeName, Object.keys(this.buildingTypes).concat(Object.keys(this.finalTypeMap)));
        if (fromObject) {
            throw new Error("Looks like you forgot to import " + typeName + " in the root \"types\" passed to Nexus makeSchema");
        }
        var suggestionsString = "";
        if (suggestions.length > 0) {
            suggestionsString = " or mean " + suggestions.join(", ");
        }
        throw new Error("Missing type " + typeName + ", did you forget to import a type to the root query" + suggestionsString + "?");
    };
    SchemaBuilder.prototype.buildUnionMembers = function (unionName, members) {
        var _this = this;
        var unionMembers = [];
        if (!members) {
            throw new Error("Missing Union members for " + unionName + "." +
                "Make sure to call the t.members(...) method in the union blocks");
        }
        members.forEach(function (member) {
            unionMembers.push(_this.getObjectType(member));
        });
        if (!unionMembers.length) {
            throw new Error("GraphQL Nexus: Union " + unionName + " must have at least one member type");
        }
        return unionMembers;
    };
    SchemaBuilder.prototype.buildObjectFields = function (fields, typeConfig, intoObject, forInterface) {
        var _this = this;
        if (forInterface === void 0) { forInterface = false; }
        fields.forEach(function (field) {
            intoObject[field.name] = _this.buildObjectField(field, typeConfig, forInterface);
        });
        return intoObject;
    };
    SchemaBuilder.prototype.buildInputObjectFields = function (fields, typeConfig) {
        var _this = this;
        var fieldMap = {};
        fields.forEach(function (field) {
            fieldMap[field.name] = _this.buildInputObjectField(field, typeConfig);
        });
        return fieldMap;
    };
    SchemaBuilder.prototype.buildObjectField = function (fieldConfig, typeConfig, forInterface) {
        if (forInterface === void 0) { forInterface = false; }
        if (!fieldConfig.type) {
            throw new Error("Missing required \"type\" field for " + typeConfig.name + "." + fieldConfig.name);
        }
        return {
            type: this.decorateType(this.getOutputType(fieldConfig.type), fieldConfig.list, this.outputNonNull(typeConfig, fieldConfig)),
            args: this.buildArgs(fieldConfig.args || {}, typeConfig),
            resolve: this.getResolver(fieldConfig, typeConfig, forInterface),
            description: fieldConfig.description,
            deprecationReason: fieldConfig.deprecation,
            subscribe: forInterface ? undefined : this.getSubscribe(fieldConfig),
        };
    };
    SchemaBuilder.prototype.buildInputObjectField = function (field, typeConfig) {
        return {
            type: this.decorateType(this.getInputType(field.type), field.list, this.inputNonNull(typeConfig, field)),
            defaultValue: field.default,
            description: field.description,
        };
    };
    SchemaBuilder.prototype.buildArgs = function (args, typeConfig) {
        var _this = this;
        var allArgs = {};
        Object.keys(args).forEach(function (argName) {
            var argDef = normalizeArg(args[argName]).value;
            allArgs[argName] = {
                type: _this.decorateType(_this.getInputType(argDef.type), argDef.list, _this.inputNonNull(typeConfig, argDef)),
                description: argDef.description,
                defaultValue: argDef.default,
            };
        });
        return allArgs;
    };
    SchemaBuilder.prototype.inputNonNull = function (typeDef, field) {
        var nullable = field.nullable, required = field.required;
        var name = typeDef.name, _a = typeDef.nonNullDefaults, nonNullDefaults = _a === void 0 ? {} : _a;
        if (typeof nullable !== "undefined" && typeof required !== "undefined") {
            throw new Error("Cannot set both nullable & required on " + name);
        }
        if (typeof nullable !== "undefined") {
            return !nullable;
        }
        if (typeof required !== "undefined") {
            return required;
        }
        // Null by default
        return utils_1.firstDefined(nonNullDefaults.input, this.nonNullDefaults.input, false);
    };
    SchemaBuilder.prototype.outputNonNull = function (typeDef, field) {
        var nullable = field.nullable;
        var _a = typeDef.nonNullDefaults, nonNullDefaults = _a === void 0 ? {} : _a;
        if (typeof nullable !== "undefined") {
            return !nullable;
        }
        // Non-Null by default
        return utils_1.firstDefined(nonNullDefaults.output, this.nonNullDefaults.output, true);
    };
    SchemaBuilder.prototype.decorateType = function (type, list, isNonNull) {
        if (list) {
            type = this.decorateList(type, list);
        }
        return (isNonNull ? graphql_1.GraphQLNonNull(type) : type);
    };
    SchemaBuilder.prototype.decorateList = function (type, list) {
        var finalType = type;
        if (!Array.isArray(list)) {
            return graphql_1.GraphQLList(graphql_1.GraphQLNonNull(type));
        }
        if (Array.isArray(list)) {
            for (var i = 0; i < list.length; i++) {
                var isNull = !list[i];
                if (!isNull) {
                    finalType = graphql_1.GraphQLNonNull(finalType);
                }
                finalType = graphql_1.GraphQLList(finalType);
            }
        }
        return finalType;
    };
    SchemaBuilder.prototype.getInterface = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isInterfaceType(type)) {
            throw new Error("Expected " + name + " to be an interfaceType, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getEnum = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isEnumType(type)) {
            throw new Error("Expected " + name + " to be an enumType, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getUnion = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isUnionType(type)) {
            throw new Error("Expected " + name + " to be a unionType, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getInputObjectType = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isInputObjectType(type)) {
            throw new Error("Expected " + name + " to be a valid input type, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getInputType = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isInputObjectType(type) && !graphql_1.isLeafType(type)) {
            throw new Error("Expected " + name + " to be a possible input type, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getOutputType = function (name) {
        var type = this.getOrBuildType(name);
        if (!graphql_1.isOutputType(type)) {
            throw new Error("Expected " + name + " to be a valid output type, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getObjectType = function (name) {
        if (wrapping_1.isNexusNamedTypeDef(name)) {
            return this.getObjectType(name.name);
        }
        var type = this.getOrBuildType(name);
        if (!graphql_1.isObjectType(type)) {
            throw new Error("Expected " + name + " to be a objectType, saw " + type.constructor.name);
        }
        return type;
    };
    SchemaBuilder.prototype.getOrBuildType = function (name, fromObject) {
        if (fromObject === void 0) { fromObject = false; }
        invariantGuard(name);
        if (wrapping_1.isNexusNamedTypeDef(name) || wrapping_1.isNexusWrappedType(name)) {
            return this.getOrBuildType(name.name, true);
        }
        if (SCALARS[name]) {
            return SCALARS[name];
        }
        if (this.finalTypeMap[name]) {
            return this.finalTypeMap[name];
        }
        if (this.buildingTypes.has(name)) {
            throw new Error("GraphQL Nexus: Circular dependency detected, while building types " + Array.from(this.buildingTypes));
        }
        var pendingType = this.pendingTypeMap[name];
        if (wrapping_1.isNexusNamedTypeDef(pendingType)) {
            this.buildingTypes.add(pendingType.name);
            if (wrapping_1.isNexusObjectTypeDef(pendingType)) {
                return this.buildObjectType(pendingType.value);
            }
            else if (wrapping_1.isNexusInterfaceTypeDef(pendingType)) {
                return this.buildInterfaceType(pendingType.value);
            }
            else if (wrapping_1.isNexusEnumTypeDef(pendingType)) {
                return this.buildEnumType(pendingType.value);
            }
            else if (wrapping_1.isNexusScalarTypeDef(pendingType)) {
                return this.buildScalarType(pendingType.value);
            }
            else if (wrapping_1.isNexusInputObjectTypeDef(pendingType)) {
                return this.buildInputObjectType(pendingType.value);
            }
            else if (wrapping_1.isNexusUnionTypeDef(pendingType)) {
                return this.buildUnionType(pendingType.value);
            }
        }
        return this.missingType(name, fromObject);
    };
    SchemaBuilder.prototype.getSubscribe = function (fieldConfig) {
        var subscribe;
        if (fieldConfig.subscribe) {
            subscribe = fieldConfig.subscribe;
            if (fieldConfig.authorize) {
                subscribe = wrapAuthorize(subscribe, fieldConfig.authorize);
            }
        }
        return subscribe;
    };
    SchemaBuilder.prototype.getResolver = function (fieldConfig, typeConfig, forInterface) {
        if (forInterface === void 0) { forInterface = false; }
        var resolver;
        if (fieldConfig.resolve) {
            resolver = fieldConfig.resolve;
        }
        if (!resolver && !forInterface) {
            resolver = typeConfig.defaultResolver;
        }
        if (fieldConfig.authorize && typeConfig.name !== "Subscription") {
            resolver = wrapAuthorize(resolver || graphql_1.defaultFieldResolver, fieldConfig.authorize);
        }
        return resolver;
    };
    SchemaBuilder.prototype.missingResolveType = function (name, location) {
        console.error(new Error("Missing resolveType for the " + name + " " + location + "." +
            "Be sure to add one in the definition block for the type, " +
            "or t.resolveType(() => null) if you don't want to implement yet"));
        return function () { return null; };
    };
    SchemaBuilder.prototype.walkInputType = function (obj) {
        var _this = this;
        var definitionBlock = new definitionBlocks_1.InputDefinitionBlock({
            typeName: obj.name,
            addField: function (f) { return _this.maybeTraverseInputType(f); },
            addDynamicInputFields: function (block, isList) {
                return _this.addDynamicInputFields(block, isList);
            },
        });
        obj.definition(definitionBlock);
        return obj;
    };
    SchemaBuilder.prototype.addDynamicInputFields = function (block, isList) {
        var _this = this;
        utils_1.eachObj(this.dynamicInputFields, function (val, methodName) {
            if (typeof val === "string") {
                return _this.addDynamicScalar(methodName, val, block);
            }
            // @ts-ignore
            block[methodName] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var config = isList ? [args[0], tslib_1.__assign({ list: isList }, args[1])] : args;
                return val.value.factory({
                    args: config,
                    typeDef: block,
                    builder: _this,
                    typeName: block.typeName,
                });
            };
        });
    };
    SchemaBuilder.prototype.addDynamicOutputFields = function (block, isList) {
        var _this = this;
        utils_1.eachObj(this.dynamicOutputFields, function (val, methodName) {
            if (typeof val === "string") {
                return _this.addDynamicScalar(methodName, val, block);
            }
            // @ts-ignore
            block[methodName] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var config = isList ? [args[0], tslib_1.__assign({ list: isList }, args[1])] : args;
                return val.value.factory({
                    args: config,
                    typeDef: block,
                    builder: _this,
                    typeName: block.typeName,
                });
            };
        });
    };
    SchemaBuilder.prototype.addDynamicScalar = function (methodName, typeName, block) {
        // @ts-ignore
        block[methodName] = function (fieldName, opts) {
            // @ts-ignore
            block.field(fieldName, tslib_1.__assign({ type: typeName }, opts));
        };
    };
    SchemaBuilder.prototype.walkOutputType = function (obj) {
        var _this = this;
        var definitionBlock = new objectType_1.ObjectDefinitionBlock({
            typeName: obj.name,
            addFieldModifications: function () { },
            addInterfaces: function () { },
            addField: function (f) { return _this.maybeTraverseOutputType(f); },
            addDynamicOutputFields: function (block, isList) {
                return _this.addDynamicOutputFields(block, isList);
            },
        });
        obj.definition(definitionBlock);
        return obj;
    };
    SchemaBuilder.prototype.walkInterfaceType = function (obj) {
        var _this = this;
        var definitionBlock = new interfaceType_1.InterfaceDefinitionBlock({
            typeName: obj.name,
            setResolveType: function () { },
            addField: function (f) { return _this.maybeTraverseOutputType(f); },
            addDynamicOutputFields: function (block, isList) {
                return _this.addDynamicOutputFields(block, isList);
            },
        });
        obj.definition(definitionBlock);
        return obj;
    };
    SchemaBuilder.prototype.maybeTraverseOutputType = function (type) {
        var _this = this;
        var args = type.args, fieldType = type.type;
        if (typeof fieldType !== "string" && !wrapping_1.isNexusWrappedType(fieldType)) {
            this.addType(fieldType);
        }
        if (args) {
            utils_1.eachObj(args, function (val) {
                var t = wrapping_1.isNexusArgDef(val) ? val.value.type : val;
                if (typeof t !== "string" && !wrapping_1.isNexusWrappedType(t)) {
                    _this.addType(t);
                }
            });
        }
    };
    SchemaBuilder.prototype.maybeTraverseInputType = function (type) {
        var fieldType = type.type;
        if (typeof fieldType !== "string" && !wrapping_1.isNexusWrappedType(fieldType)) {
            this.addType(fieldType);
        }
    };
    SchemaBuilder.prototype.walkNamedTypes = function (namedType) {
        var _this = this;
        if (graphql_1.isObjectType(namedType)) {
            utils_1.eachObj(namedType.getFields(), function (val) { return _this.addObjectField(val); });
        }
        if (graphql_1.isInterfaceType(namedType)) {
            utils_1.eachObj(namedType.getFields(), function (val) { return _this.addObjectField(val); });
        }
        if (graphql_1.isInputObjectType(namedType)) {
            utils_1.eachObj(namedType.getFields(), function (val) {
                return _this.addType(graphql_1.getNamedType(val.type));
            });
        }
    };
    SchemaBuilder.prototype.addObjectField = function (obj) {
        var _this = this;
        this.addType(graphql_1.getNamedType(obj.type));
        if (obj.args) {
            obj.args.forEach(function (val) { return _this.addType(graphql_1.getNamedType(val.type)); });
        }
    };
    return SchemaBuilder;
}());
exports.SchemaBuilder = SchemaBuilder;
function extendError(name) {
    return new Error(name + " was already defined and imported as a type, check the docs for extending types");
}
function wrapAuthorize(resolver, authorize) {
    var _this = this;
    var nexusAuthWrapped = function (root, args, ctx, info) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var authResult, fieldName, parentTypeName;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, authorize(root, args, ctx, info)];
                case 1:
                    authResult = _a.sent();
                    if (authResult === true) {
                        return [2 /*return*/, resolver(root, args, ctx, info)];
                    }
                    if (authResult === false) {
                        throw new Error("Not authorized");
                    }
                    if (authResult instanceof Error) {
                        throw authResult;
                    }
                    fieldName = info.fieldName, parentTypeName = info.parentType.name;
                    throw new Error("Nexus authorize for " + parentTypeName + "." + fieldName + " Expected a boolean or Error, saw " + authResult);
            }
        });
    }); };
    nexusAuthWrapped.nexusWrappedResolver = resolver;
    return nexusAuthWrapped;
}
exports.wrapAuthorize = wrapAuthorize;
/**
 * Builds the types, normalizing the "types" passed into the schema for a
 * better developer experience. This is primarily useful for testing
 * type generation
 */
function buildTypes(types, config, schemaBuilder) {
    if (config === void 0) { config = { outputs: false }; }
    var builder = schemaBuilder || new SchemaBuilder(config);
    addTypes(builder, types);
    return builder.getFinalTypeMap();
}
exports.buildTypes = buildTypes;
function addTypes(builder, types) {
    if (!types) {
        return;
    }
    if (wrapping_1.isNexusWrappedType(types)) {
        addTypes(builder, types.fn(builder));
        return;
    }
    if (wrapping_1.isNexusNamedTypeDef(types) ||
        wrapping_1.isNexusExtendTypeDef(types) ||
        wrapping_1.isNexusExtendInputTypeDef(types) ||
        graphql_1.isNamedType(types) ||
        wrapping_1.isNexusDynamicInputMethod(types) ||
        wrapping_1.isNexusDynamicOutputMethod(types)) {
        builder.addType(types);
    }
    else if (Array.isArray(types)) {
        types.forEach(function (typeDef) { return addTypes(builder, typeDef); });
    }
    else if (utils_1.isObject(types)) {
        Object.keys(types).forEach(function (key) { return addTypes(builder, types[key]); });
    }
}
/**
 * Builds the schema, we may return more than just the schema
 * from this one day.
 */
function makeSchemaInternal(options, schemaBuilder) {
    var _a = buildTypes(options.types, options, schemaBuilder), typeMap = _a.typeMap, dynamicFields = _a.dynamicFields, rootTypings = _a.rootTypings;
    var Query = typeMap.Query, Mutation = typeMap.Mutation, Subscription = typeMap.Subscription;
    if (!graphql_1.isObjectType(Query)) {
        throw new Error("Expected Query to be a objectType, saw " + Query.constructor.name);
    }
    if (Mutation && !graphql_1.isObjectType(Mutation)) {
        throw new Error("Expected Mutation to be a objectType, saw " + Mutation.constructor.name);
    }
    if (Subscription && !graphql_1.isObjectType(Subscription)) {
        throw new Error("Expected Subscription to be a objectType, saw " + Subscription.constructor.name);
    }
    var schema = new graphql_1.GraphQLSchema({
        query: Query,
        mutation: Mutation,
        subscription: Subscription,
        types: utils_1.objValues(typeMap),
    });
    // Loosely related to https://github.com/graphql/graphql-js/issues/1527#issuecomment-457828990
    schema.extensions = tslib_1.__assign({}, schema.extensions, { nexus: {
            rootTypings: rootTypings,
            dynamicFields: dynamicFields,
        } });
    return { schema: schema };
}
exports.makeSchemaInternal = makeSchemaInternal;
/**
 * Defines the GraphQL schema, by combining the GraphQL types defined
 * by the GraphQL Nexus layer or any manually defined GraphQLType objects.
 *
 * Requires at least one type be named "Query", which will be used as the
 * root query type.
 */
function makeSchema(options) {
    var schema = makeSchemaInternal(options).schema;
    // Only in development envs do we want to worry about regenerating the
    // schema definition and/or generated types.
    var _a = options.shouldGenerateArtifacts, shouldGenerateArtifacts = _a === void 0 ? Boolean(!process.env.NODE_ENV || process.env.NODE_ENV === "development") : _a;
    if (shouldGenerateArtifacts) {
        // Generating in the next tick allows us to use the schema
        // in the optional thunk for the typegen config
        new typegenMetadata_1.TypegenMetadata(options).generateArtifacts(schema).catch(function (e) {
            console.error(e);
        });
    }
    return schema;
}
exports.makeSchema = makeSchema;
function invariantGuard(val) {
    if (!Boolean(val)) {
        throw new Error("Nexus Error: This should never happen, " +
            "please check your code or open a GitHub ticket if you believe this is an issue with Nexus");
    }
}
function normalizeArg(argVal) {
    if (wrapping_1.isNexusArgDef(argVal)) {
        return argVal;
    }
    return args_1.arg({ type: argVal });
}
//# sourceMappingURL=builder.js.map