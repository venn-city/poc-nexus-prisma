import {
  GraphQLArgument,
  GraphQLField,
  GraphQLInputField,
  GraphQLInputType,
  GraphQLInterfaceType,
  GraphQLObjectType,
  GraphQLOutputType,
  GraphQLScalarType,
  GraphQLSchema,
} from "graphql";
import { TypegenInfo, NexusSchemaExtensions } from "./builder";
import { GroupedTypes } from "./utils";
import { WrappedResolver } from "./definitions/_types";
declare type TypeFieldMapping = Record<
  string,
  Record<string, [string, string]>
>;
declare type TypeMapping = Record<string, string>;
declare type RootTypeMapping = Record<
  string,
  string | Record<string, [string, string]>
>;
/**
 * We track and output a few main things:
 *
 * 1. "root" types, or the values that fill the first
 *    argument for a given object type
 *
 * 2. "arg" types, the values that are arguments to output fields.
 *
 * 3. "return" types, the values returned from the resolvers... usually
 *    just list/nullable variations on the "root" types for other types
 *
 * 4. The names of all types, grouped by type.
 *
 * - Non-scalar types will get a dedicated "Root" type associated with it
 */
export declare class Typegen {
  protected schema: GraphQLSchema;
  protected typegenInfo: TypegenInfo & {
    typegenFile: string;
  };
  protected extensions: NexusSchemaExtensions;
  groupedTypes: GroupedTypes;
  constructor(
    schema: GraphQLSchema,
    typegenInfo: TypegenInfo & {
      typegenFile: string;
    },
    extensions: NexusSchemaExtensions
  );
  print(): string;
  printHeaders(): string;
  printGenTypeMap(): string;
  printDynamicImport(): string;
  printDynamicInputFieldDefinitions(): string | never[];
  printDynamicOutputFieldDefinitions(): string | never[];
  printInheritedFieldMap(): string;
  printContext(): string;
  buildResolveSourceTypeMap(): Record<string, string>;
  printAbstractResolveReturnTypeMap(): string;
  buildResolveReturnTypesMap(): Record<string, string>;
  printTypeNames(name: keyof GroupedTypes, exportName: string): string;
  buildEnumTypeMap(): Record<string, string>;
  buildInputTypeMap(): Record<string, Record<string, [string, string]>>;
  printInputTypeMap(): string;
  printEnumTypeMap(): string;
  buildRootTypeMap(): Record<string, string | Record<string, [string, string]>>;
  resolveBackingType(typeName: string): string | undefined;
  buildAllTypesMap(): Record<string, string>;
  hasResolver(
    field: GraphQLField<any, any> & {
      resolve?: WrappedResolver;
    },
    _type: GraphQLObjectType | GraphQLInterfaceType
  ): boolean;
  printRootTypeMap(): string;
  printAllTypesMap(): string;
  buildArgTypeMap(): Record<
    string,
    Record<string, Record<string, [string, string]>>
  >;
  printArgTypeMap(): string;
  buildReturnTypeMap(): Record<string, Record<string, [string, string]>>;
  printOutputType(type: GraphQLOutputType): string;
  typeToArr(type: GraphQLOutputType): any[];
  printReturnTypeMap(): string;
  normalizeArg(arg: GraphQLInputField | GraphQLArgument): [string, string];
  argSeparator(type: GraphQLInputType): ":" | "?:";
  argTypeRepresentation(arg: GraphQLInputType): string;
  argTypeArr(arg: GraphQLInputType): any[];
  printTypeInterface(interfaceName: string, typeMapping: TypeMapping): string;
  printRootTypeFieldInterface(
    interfaceName: string,
    typeMapping: RootTypeMapping
  ): string;
  printTypeFieldInterface(
    interfaceName: string,
    typeMapping: TypeFieldMapping,
    source: string
  ): string;
  printArgTypeFieldInterface(
    typeMapping: Record<string, TypeFieldMapping>
  ): string;
  printObj: (
    space: string,
    source: string
  ) => (val: Record<string, [string, string]>, key: string) => string;
  printScalar(type: GraphQLScalarType): string;
}
export {};
