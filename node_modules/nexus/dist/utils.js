"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var path_1 = tslib_1.__importDefault(require("path"));
function log(msg) {
    console.log("GraphQL Nexus: " + msg);
}
exports.log = log;
function withDeprecationComment(description) {
    return description;
}
exports.withDeprecationComment = withDeprecationComment;
exports.isInterfaceField = function (type, fieldName) {
    return type.getInterfaces().some(function (i) { return Boolean(i.getFields()[fieldName]); });
};
// ----------------------------
/**
 *
 * Copied from graphql-js:
 *
 */
/**
 * Given an invalid input string and a list of valid options, returns a filtered
 * list of valid options sorted based on their similarity with the input.
 */
function suggestionList(input, options) {
    if (input === void 0) { input = ""; }
    if (options === void 0) { options = []; }
    var optionsByDistance = Object.create(null);
    var oLength = options.length;
    var inputThreshold = input.length / 2;
    for (var i = 0; i < oLength; i++) {
        var distance = lexicalDistance(input, options[i]);
        var threshold = Math.max(inputThreshold, options[i].length / 2, 1);
        if (distance <= threshold) {
            optionsByDistance[options[i]] = distance;
        }
    }
    return Object.keys(optionsByDistance).sort(function (a, b) {
        return optionsByDistance[a] - optionsByDistance[b];
    });
}
exports.suggestionList = suggestionList;
/**
 * Computes the lexical distance between strings A and B.
 *
 * The "distance" between two strings is given by counting the minimum number
 * of edits needed to transform string A into string B. An edit can be an
 * insertion, deletion, or substitution of a single character, or a swap of two
 * adjacent characters.
 *
 * Includes a custom alteration from Damerau-Levenshtein to treat case changes
 * as a single edit which helps identify mis-cased values with an edit distance
 * of 1.
 *
 * This distance can be useful for detecting typos in input or sorting
 */
function lexicalDistance(aStr, bStr) {
    if (aStr === bStr) {
        return 0;
    }
    var i;
    var j;
    var d = [];
    var a = aStr.toLowerCase();
    var b = bStr.toLowerCase();
    var aLength = a.length;
    var bLength = b.length; // Any case change counts as a single edit
    if (a === b) {
        return 1;
    }
    for (i = 0; i <= aLength; i++) {
        d[i] = [i];
    }
    for (j = 1; j <= bLength; j++) {
        d[0][j] = j;
    }
    for (i = 1; i <= aLength; i++) {
        for (j = 1; j <= bLength; j++) {
            var cost = a[i - 1] === b[j - 1] ? 0 : 1;
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
        }
    }
    return d[aLength][bLength];
}
// ----------------------------
function objValues(obj) {
    return Object.keys(obj).reduce(function (result, key) {
        result.push(obj[key]);
        return result;
    }, []);
}
exports.objValues = objValues;
function mapObj(obj, mapper) {
    return Object.keys(obj).map(function (key, index) { return mapper(obj[key], key, index); });
}
exports.mapObj = mapObj;
function eachObj(obj, iter) {
    Object.keys(obj).forEach(function (name, i) { return iter(obj[name], name, i); });
}
exports.eachObj = eachObj;
exports.isObject = function (obj) {
    return obj !== null && typeof obj === "object";
};
exports.assertAbsolutePath = function (pathName, property) {
    if (!path_1.default.isAbsolute(pathName)) {
        throw new Error("Expected path for " + property + " to be a string, saw " + pathName);
    }
    return pathName;
};
function groupTypes(schema) {
    var groupedTypes = {
        input: [],
        interface: [],
        object: [],
        union: [],
        enum: [],
        scalar: Array.from(graphql_1.specifiedScalarTypes),
    };
    var schemaTypeMap = schema.getTypeMap();
    Object.keys(schemaTypeMap)
        .sort()
        .forEach(function (typeName) {
        if (typeName.indexOf("__") === 0) {
            return;
        }
        var type = schema.getType(typeName);
        if (graphql_1.isObjectType(type)) {
            groupedTypes.object.push(type);
        }
        else if (graphql_1.isInputObjectType(type)) {
            groupedTypes.input.push(type);
        }
        else if (graphql_1.isScalarType(type) && !graphql_1.isSpecifiedScalarType(type)) {
            groupedTypes.scalar.push(type);
        }
        else if (graphql_1.isUnionType(type)) {
            groupedTypes.union.push(type);
        }
        else if (graphql_1.isInterfaceType(type)) {
            groupedTypes.interface.push(type);
        }
        else if (graphql_1.isEnumType(type)) {
            groupedTypes.enum.push(type);
        }
    });
    return groupedTypes;
}
exports.groupTypes = groupTypes;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (typeof arg !== "undefined") {
            return arg;
        }
    }
    throw new Error("At least one of the values should be defined");
}
exports.firstDefined = firstDefined;
// eslint-disable-next-line no-redeclare
function isPromise(value) {
    return Boolean(value && typeof value.then === "function");
}
exports.isPromise = isPromise;
function relativePathTo(absolutePath, outputPath) {
    var filename = path_1.default.basename(absolutePath).replace(/(\.d)?\.ts/, "");
    var relative = path_1.default.relative(path_1.default.dirname(outputPath), path_1.default.dirname(absolutePath));
    if (relative.indexOf(".") !== 0) {
        return "./" + path_1.default.join(relative, filename);
    }
    return path_1.default.join(relative, filename);
}
exports.relativePathTo = relativePathTo;
//# sourceMappingURL=utils.js.map