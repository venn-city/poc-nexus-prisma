"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var path_1 = tslib_1.__importDefault(require("path"));
var utils_1 = require("./utils");
var SpecifiedScalars = {
    ID: "string",
    String: "string",
    Float: "number",
    Int: "number",
    Boolean: "boolean",
};
/**
 * We track and output a few main things:
 *
 * 1. "root" types, or the values that fill the first
 *    argument for a given object type
 *
 * 2. "arg" types, the values that are arguments to output fields.
 *
 * 3. "return" types, the values returned from the resolvers... usually
 *    just list/nullable variations on the "root" types for other types
 *
 * 4. The names of all types, grouped by type.
 *
 * - Non-scalar types will get a dedicated "Root" type associated with it
 */
var Typegen = /** @class */ (function () {
    function Typegen(schema, typegenInfo, extensions) {
        this.schema = schema;
        this.typegenInfo = typegenInfo;
        this.extensions = extensions;
        this.printObj = function (space, source) { return function (val, key) {
            return ["" + space + key + ": { // " + source]
                .concat(utils_1.mapObj(val, function (v2, k2) {
                return space + "  " + k2 + v2[0] + " " + v2[1];
            }))
                .concat(space + "}")
                .join("\n");
        }; };
        this.groupedTypes = utils_1.groupTypes(schema);
    }
    Typegen.prototype.print = function () {
        return [
            this.printHeaders(),
            this.printInputTypeMap(),
            this.printEnumTypeMap(),
            this.printRootTypeMap(),
            this.printAllTypesMap(),
            this.printReturnTypeMap(),
            this.printArgTypeMap(),
            this.printAbstractResolveReturnTypeMap(),
            this.printInheritedFieldMap(),
            this.printTypeNames("object", "NexusGenObjectNames"),
            this.printTypeNames("input", "NexusGenInputNames"),
            this.printTypeNames("enum", "NexusGenEnumNames"),
            this.printTypeNames("interface", "NexusGenInterfaceNames"),
            this.printTypeNames("scalar", "NexusGenScalarNames"),
            this.printTypeNames("union", "NexusGenUnionNames"),
            this.printGenTypeMap(),
        ].join("\n\n");
    };
    Typegen.prototype.printHeaders = function () {
        return [
            this.typegenInfo.headers.join("\n"),
            this.typegenInfo.imports.join("\n"),
            this.printDynamicImport(),
            this.printDynamicInputFieldDefinitions(),
            this.printDynamicOutputFieldDefinitions(),
            GLOBAL_DECLARATION,
        ].join("\n");
    };
    Typegen.prototype.printGenTypeMap = function () {
        return ["export interface NexusGenTypes {"]
            .concat([
            "  context: " + this.printContext() + ";",
            "  inputTypes: NexusGenInputs;",
            "  rootTypes: NexusGenRootTypes;",
            "  argTypes: NexusGenArgTypes;",
            "  fieldTypes: NexusGenFieldTypes;",
            "  allTypes: NexusGenAllTypes;",
            "  inheritedFields: NexusGenInheritedFields;",
            "  objectNames: NexusGenObjectNames;",
            "  inputNames: NexusGenInputNames;",
            "  enumNames: NexusGenEnumNames;",
            "  interfaceNames: NexusGenInterfaceNames;",
            "  scalarNames: NexusGenScalarNames;",
            "  unionNames: NexusGenUnionNames;",
            "  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];",
            "  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];",
            "  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']",
            "  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];",
            "  abstractResolveReturn: NexusGenAbstractResolveReturnTypes;",
        ])
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.printDynamicImport = function () {
        var _a = this.extensions, _b = _a.dynamicFields, dynamicInputFields = _b.dynamicInputFields, dynamicOutputFields = _b.dynamicOutputFields, rootTypings = _a.rootTypings;
        var imports = [];
        if ([dynamicInputFields, dynamicOutputFields].some(function (o) { return Object.keys(o).length > 0; })) {
            imports.push("import { core } from \"nexus\"");
        }
        var importMap = {};
        var outputPath = this.typegenInfo.typegenFile;
        utils_1.eachObj(rootTypings, function (val, key) {
            if (typeof val !== "string") {
                var importPath = (path_1.default.isAbsolute(val.path)
                    ? utils_1.relativePathTo(val.path, outputPath)
                    : val.path).replace(/(\.d)?\.ts/, "");
                importMap[importPath] = importMap[importPath] || new Set();
                importMap[importPath].add(val.alias ? val.name + " as " + val.alias : val.name);
            }
        });
        utils_1.eachObj(importMap, function (val, key) {
            imports.push("import { " + Array.from(val).join(", ") + " } from " + JSON.stringify(key));
        });
        return imports.join("\n");
    };
    Typegen.prototype.printDynamicInputFieldDefinitions = function () {
        var dynamicInputFields = this.extensions.dynamicFields.dynamicInputFields;
        // If there is nothing custom... exit
        if (!Object.keys(dynamicInputFields).length) {
            return [];
        }
        return [
            "declare global {",
            "  interface NexusGenCustomInputMethods<TypeName extends string> {",
        ]
            .concat(utils_1.mapObj(dynamicInputFields, function (val, key) {
            if (typeof val === "string") {
                return "    " + key + "<FieldName extends string>(fieldName: FieldName, opts?: core.ScalarInputFieldConfig<core.GetGen3<\"inputTypes\", TypeName, FieldName>>): void // " + JSON.stringify(val) + ";";
            }
            return "    " + key + (val.value.typeDefinition ||
                "(...args: any): void");
        }))
            .concat(["  }", "}"])
            .join("\n");
    };
    Typegen.prototype.printDynamicOutputFieldDefinitions = function () {
        var dynamicOutputFields = this.extensions.dynamicFields.dynamicOutputFields;
        // If there is nothing custom... exit
        if (!Object.keys(dynamicOutputFields).length) {
            return [];
        }
        return [
            "declare global {",
            "  interface NexusGenCustomOutputMethods<TypeName extends string> {",
        ]
            .concat(utils_1.mapObj(dynamicOutputFields, function (val, key) {
            if (typeof val === "string") {
                return "    " + key + "<FieldName extends string>(fieldName: FieldName, ...opts: core.ScalarOutSpread<TypeName, FieldName>): void // " + JSON.stringify(val) + ";";
            }
            return "    " + key + (val.value.typeDefinition ||
                "(...args: any): void");
        }))
            .concat(["  }", "}"])
            .join("\n");
    };
    Typegen.prototype.printInheritedFieldMap = function () {
        // TODO:
        return "export interface NexusGenInheritedFields {}";
    };
    Typegen.prototype.printContext = function () {
        return this.typegenInfo.contextType || "{}";
    };
    Typegen.prototype.buildResolveSourceTypeMap = function () {
        var _this = this;
        var sourceMap = {};
        var abstractTypes = [];
        abstractTypes
            .concat(this.groupedTypes.union)
            .concat(this.groupedTypes.interface)
            .forEach(function (type) {
            if (graphql_1.isInterfaceType(type)) {
                var possibleNames = _this.schema
                    .getPossibleTypes(type)
                    .map(function (t) { return t.name; });
                if (possibleNames.length > 0) {
                    sourceMap[type.name] = possibleNames
                        .map(function (val) { return "NexusGenRootTypes['" + val + "']"; })
                        .join(" | ");
                }
            }
            else {
                sourceMap[type.name] = type
                    .getTypes()
                    .map(function (t) { return "NexusGenRootTypes['" + t.name + "']"; })
                    .join(" | ");
            }
        });
        return sourceMap;
    };
    Typegen.prototype.printAbstractResolveReturnTypeMap = function () {
        return this.printTypeInterface("NexusGenAbstractResolveReturnTypes", this.buildResolveReturnTypesMap());
    };
    Typegen.prototype.buildResolveReturnTypesMap = function () {
        var _this = this;
        var sourceMap = {};
        var abstractTypes = [];
        abstractTypes
            .concat(this.groupedTypes.union)
            .concat(this.groupedTypes.interface)
            .forEach(function (type) {
            if (graphql_1.isInterfaceType(type)) {
                var possibleNames = _this.schema
                    .getPossibleTypes(type)
                    .map(function (t) { return t.name; });
                if (possibleNames.length > 0) {
                    sourceMap[type.name] = possibleNames
                        .map(function (val) { return JSON.stringify(val); })
                        .join(" | ");
                }
            }
            else {
                sourceMap[type.name] = type
                    .getTypes()
                    .map(function (t) { return JSON.stringify(t.name); })
                    .join(" | ");
            }
        });
        return sourceMap;
    };
    Typegen.prototype.printTypeNames = function (name, exportName) {
        var obj = this.groupedTypes[name];
        var typeDef = obj.length === 0
            ? "never"
            : obj
                .map(function (o) { return JSON.stringify(o.name); })
                .sort()
                .join(" | ");
        return "export type " + exportName + " = " + typeDef + ";";
    };
    Typegen.prototype.buildEnumTypeMap = function () {
        var _this = this;
        var enumMap = {};
        this.groupedTypes.enum.forEach(function (e) {
            var backingType = _this.resolveBackingType(e.name);
            if (backingType) {
                enumMap[e.name] = backingType;
            }
            else {
                var values = e.getValues().map(function (val) { return JSON.stringify(val.value); });
                enumMap[e.name] = values.join(" | ");
            }
        });
        return enumMap;
    };
    Typegen.prototype.buildInputTypeMap = function () {
        var _this = this;
        var inputObjMap = {};
        this.groupedTypes.input.forEach(function (input) {
            utils_1.eachObj(input.getFields(), function (field) {
                inputObjMap[input.name] = inputObjMap[input.name] || {};
                inputObjMap[input.name][field.name] = _this.normalizeArg(field);
            });
        });
        return inputObjMap;
    };
    Typegen.prototype.printInputTypeMap = function () {
        return this.printTypeFieldInterface("NexusGenInputs", this.buildInputTypeMap(), "input type");
    };
    Typegen.prototype.printEnumTypeMap = function () {
        return this.printTypeInterface("NexusGenEnums", this.buildEnumTypeMap());
    };
    Typegen.prototype.buildRootTypeMap = function () {
        var _this = this;
        var rootTypeMap = {};
        var hasFields = [];
        hasFields
            .concat(this.groupedTypes.object)
            .concat(this.groupedTypes.interface)
            .concat(this.groupedTypes.scalar)
            .concat(this.groupedTypes.union)
            .forEach(function (type) {
            var rootTyping = _this.resolveBackingType(type.name);
            if (rootTyping) {
                rootTypeMap[type.name] = rootTyping;
                return;
            }
            if (graphql_1.isScalarType(type)) {
                if (graphql_1.isSpecifiedScalarType(type)) {
                    rootTypeMap[type.name] =
                        SpecifiedScalars[type.name];
                }
                else {
                    rootTypeMap[type.name] = "any";
                }
            }
            else if (graphql_1.isUnionType(type)) {
                rootTypeMap[type.name] = type
                    .getTypes()
                    .map(function (t) { return "NexusGenRootTypes['" + t.name + "']"; })
                    .join(" | ");
            }
            else if (graphql_1.isInterfaceType(type)) {
                var possibleRoots = _this.schema
                    .getPossibleTypes(type)
                    .map(function (t) { return "NexusGenRootTypes['" + t.name + "']"; });
                if (possibleRoots.length > 0) {
                    rootTypeMap[type.name] = possibleRoots.join(" | ");
                }
                else {
                    rootTypeMap[type.name] = "any";
                }
            }
            else if (type.name === "Query" || type.name === "Mutation") {
                rootTypeMap[type.name] = "{}";
            }
            else {
                utils_1.eachObj(type.getFields(), function (field) {
                    var obj = (rootTypeMap[type.name] = rootTypeMap[type.name] || {});
                    if (!_this.hasResolver(field, type)) {
                        if (typeof obj !== "string") {
                            obj[field.name] = [
                                _this.argSeparator(field.type),
                                _this.printOutputType(field.type),
                            ];
                        }
                    }
                });
            }
        });
        return rootTypeMap;
    };
    Typegen.prototype.resolveBackingType = function (typeName) {
        var rootTyping = this.extensions.rootTypings[typeName];
        if (rootTyping) {
            return typeof rootTyping === "string" ? rootTyping : rootTyping.name;
        }
        return this.typegenInfo.backingTypeMap[typeName];
    };
    Typegen.prototype.buildAllTypesMap = function () {
        var typeMap = {};
        var toCheck = [];
        toCheck
            .concat(this.groupedTypes.input)
            .concat(this.groupedTypes.enum)
            .forEach(function (type) {
            if (graphql_1.isInputObjectType(type)) {
                typeMap[type.name] = "NexusGenInputs['" + type.name + "']";
            }
            else if (graphql_1.isEnumType(type)) {
                typeMap[type.name] = "NexusGenEnums['" + type.name + "']";
            }
        });
        return typeMap;
    };
    Typegen.prototype.hasResolver = function (field, _type // Used in tests
    ) {
        if (field.resolve) {
            if (field.resolve.nexusWrappedResolver !== graphql_1.defaultFieldResolver) {
                return true;
            }
        }
        return false;
    };
    Typegen.prototype.printRootTypeMap = function () {
        return this.printRootTypeFieldInterface("NexusGenRootTypes", this.buildRootTypeMap());
    };
    Typegen.prototype.printAllTypesMap = function () {
        var typeMapping = this.buildAllTypesMap();
        return ["export interface NexusGenAllTypes extends NexusGenRootTypes {"]
            .concat(utils_1.mapObj(typeMapping, function (val, key) {
            return "  " + key + ": " + val + ";";
        }))
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.buildArgTypeMap = function () {
        var _this = this;
        var argTypeMap = {};
        var hasFields = [];
        hasFields
            .concat(this.groupedTypes.object)
            .concat(this.groupedTypes.interface)
            .forEach(function (type) {
            utils_1.eachObj(type.getFields(), function (field) {
                if (field.args.length > 0) {
                    argTypeMap[type.name] = argTypeMap[type.name] || {};
                    argTypeMap[type.name][field.name] = field.args.reduce(function (obj, arg) {
                        obj[arg.name] = _this.normalizeArg(arg);
                        return obj;
                    }, {});
                }
            });
        });
        return argTypeMap;
    };
    Typegen.prototype.printArgTypeMap = function () {
        return this.printArgTypeFieldInterface(this.buildArgTypeMap());
    };
    Typegen.prototype.buildReturnTypeMap = function () {
        var _this = this;
        var returnTypeMap = {};
        var hasFields = [];
        hasFields
            .concat(this.groupedTypes.object)
            .concat(this.groupedTypes.interface)
            .forEach(function (type) {
            utils_1.eachObj(type.getFields(), function (field) {
                returnTypeMap[type.name] = returnTypeMap[type.name] || {};
                returnTypeMap[type.name][field.name] = [
                    ":",
                    _this.printOutputType(field.type),
                ];
            });
        });
        return returnTypeMap;
    };
    Typegen.prototype.printOutputType = function (type) {
        var returnType = this.typeToArr(type);
        function combine(item) {
            if (item.length === 1) {
                if (Array.isArray(item[0])) {
                    var toPrint = combine(item[0]);
                    return toPrint.indexOf("null") === -1
                        ? toPrint + "[]"
                        : "Array<" + toPrint + ">";
                }
                return item[0];
            }
            if (Array.isArray(item[1])) {
                var toPrint = combine(item[1]);
                return toPrint.indexOf("null") === -1
                    ? toPrint + "[] | null"
                    : "Array<" + toPrint + "> | null";
            }
            return item[1] + " | null";
        }
        return combine(returnType) + "; // " + type;
    };
    Typegen.prototype.typeToArr = function (type) {
        var typing = [];
        if (graphql_1.isNonNullType(type)) {
            type = type.ofType;
        }
        else {
            typing.push(null);
        }
        if (graphql_1.isListType(type)) {
            typing.push(this.typeToArr(type.ofType));
        }
        else if (graphql_1.isScalarType(type)) {
            typing.push(this.printScalar(type));
        }
        else if (graphql_1.isEnumType(type)) {
            typing.push("NexusGenEnums['" + type.name + "']");
        }
        else if (graphql_1.isObjectType(type) ||
            graphql_1.isInterfaceType(type) ||
            graphql_1.isUnionType(type)) {
            typing.push("NexusGenRootTypes['" + type.name + "']");
        }
        return typing;
    };
    Typegen.prototype.printReturnTypeMap = function () {
        return this.printTypeFieldInterface("NexusGenFieldTypes", this.buildReturnTypeMap(), "field return type");
    };
    Typegen.prototype.normalizeArg = function (arg) {
        return [this.argSeparator(arg.type), this.argTypeRepresentation(arg.type)];
    };
    Typegen.prototype.argSeparator = function (type) {
        if (graphql_1.isNonNullType(type)) {
            return ":";
        }
        return "?:";
    };
    Typegen.prototype.argTypeRepresentation = function (arg) {
        var argType = this.argTypeArr(arg);
        function combine(item) {
            if (item.length === 1) {
                if (Array.isArray(item[0])) {
                    var toPrint = combine(item[0]);
                    return toPrint.indexOf("null") === -1
                        ? toPrint + "[]"
                        : "Array<" + toPrint + ">";
                }
                return item[0];
            }
            if (Array.isArray(item[1])) {
                var toPrint = combine(item[1]);
                return toPrint.indexOf("null") === -1
                    ? toPrint + "[] | null"
                    : "Array<" + toPrint + "> | null";
            }
            return item[1] + " | null";
        }
        return combine(argType) + "; // " + arg;
    };
    Typegen.prototype.argTypeArr = function (arg) {
        var typing = [];
        if (graphql_1.isNonNullType(arg)) {
            arg = arg.ofType;
        }
        else {
            typing.push(null);
        }
        if (graphql_1.isListType(arg)) {
            typing.push(this.argTypeArr(arg.ofType));
        }
        else if (graphql_1.isScalarType(arg)) {
            typing.push(this.printScalar(arg));
        }
        else if (graphql_1.isEnumType(arg)) {
            typing.push("NexusGenEnums['" + arg.name + "']");
        }
        else if (graphql_1.isInputObjectType(arg)) {
            typing.push("NexusGenInputs['" + arg.name + "']");
        }
        return typing;
    };
    Typegen.prototype.printTypeInterface = function (interfaceName, typeMapping) {
        return ["export interface " + interfaceName + " {"]
            .concat(utils_1.mapObj(typeMapping, function (val, key) { return "  " + key + ": " + val; }))
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.printRootTypeFieldInterface = function (interfaceName, typeMapping) {
        var _this = this;
        return ["export interface " + interfaceName + " {"]
            .concat(utils_1.mapObj(typeMapping, function (val, key) {
            if (typeof val === "string") {
                return "  " + key + ": " + val + ";";
            }
            if (Object.keys(val).length === 0) {
                return "  " + key + ": {};";
            }
            return _this.printObj("  ", "root type")(val, key);
        }))
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.printTypeFieldInterface = function (interfaceName, typeMapping, source) {
        return ["export interface " + interfaceName + " {"]
            .concat(utils_1.mapObj(typeMapping, this.printObj("  ", source)))
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.printArgTypeFieldInterface = function (typeMapping) {
        var _this = this;
        return ["export interface NexusGenArgTypes {"]
            .concat(utils_1.mapObj(typeMapping, function (val, key) {
            return ["  " + key + ": {"]
                .concat(utils_1.mapObj(val, _this.printObj("    ", "args")))
                .concat("  }")
                .join("\n");
        }))
            .concat("}")
            .join("\n");
    };
    Typegen.prototype.printScalar = function (type) {
        if (graphql_1.isSpecifiedScalarType(type)) {
            return SpecifiedScalars[type.name];
        }
        var backingType = this.typegenInfo.backingTypeMap[type.name];
        if (typeof backingType === "string") {
            return backingType;
        }
        else {
            return "any";
        }
    };
    return Typegen;
}());
exports.Typegen = Typegen;
var GLOBAL_DECLARATION = "\ndeclare global {\n  interface NexusGen extends NexusGenTypes {}\n}";
//# sourceMappingURL=typegen.js.map