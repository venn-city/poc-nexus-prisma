"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dynamicMethod_1 = require("../dynamicMethod");
var objectType_1 = require("../definitions/objectType");
var args_1 = require("../definitions/args");
var basicCollectionMap = new Map();
exports.Collection = dynamicMethod_1.dynamicOutputMethod({
    name: "collection",
    typeDefinition: "<FieldName extends string>(fieldName: FieldName, opts: {\n      type: NexusGenObjectNames | NexusGenInterfaceNames | core.NexusObjectTypeDef<string> | core.NexusInterfaceTypeDef<string>,\n      nodes: core.SubFieldResolver<TypeName, FieldName, \"nodes\">,\n      totalCount: core.SubFieldResolver<TypeName, FieldName, \"totalCount\">,\n      args?: core.ArgsRecord,\n      nullable?: boolean,\n      description?: string\n    }): void;",
    factory: function (_a) {
        var t = _a.typeDef, _b = _a.args, fieldName = _b[0], config = _b[1];
        var type = typeof config.type === "string" ? config.type : config.type.name;
        if (config.list) {
            throw new Error("Collection field " + fieldName + "." + type + " cannot be used as a list.");
        }
        if (!basicCollectionMap.has(type)) {
            basicCollectionMap.set(type, objectType_1.objectType({
                name: type + "Collection",
                definition: function (c) {
                    c.int("totalCount");
                    c.list.field("nodes", { type: type });
                },
            }));
        }
        t.field(fieldName, {
            type: basicCollectionMap.get(type),
            args: config.args || {
                page: args_1.intArg(),
                perPage: args_1.intArg(),
            },
            nullable: config.nullable,
            description: config.description,
            resolve: function (root, args, ctx, info) {
                var nodesResolver = function () {
                    var fArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        fArgs[_i] = arguments[_i];
                    }
                    return config.nodes(root, args, ctx, fArgs[3]);
                };
                var totalCountResolver = function () {
                    var fArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        fArgs[_i] = arguments[_i];
                    }
                    return config.totalCount(root, args, ctx, fArgs[3]);
                };
                return {
                    nodes: nodesResolver,
                    totalCount: totalCountResolver,
                };
            },
        });
    },
});
//# sourceMappingURL=collection.js.map