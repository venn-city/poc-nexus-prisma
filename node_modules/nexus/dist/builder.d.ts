import {
  GraphQLEnumType,
  GraphQLFieldConfig,
  GraphQLFieldConfigArgumentMap,
  GraphQLFieldConfigMap,
  GraphQLFieldResolver,
  GraphQLInputFieldConfig,
  GraphQLInputFieldConfigMap,
  GraphQLInputObjectType,
  GraphQLInputType,
  GraphQLInterfaceType,
  GraphQLNamedType,
  GraphQLObjectType,
  GraphQLOutputType,
  GraphQLScalarType,
  GraphQLSchema,
  GraphQLUnionType,
  GraphQLField,
} from "graphql";
import { NexusArgConfig, ArgsRecord } from "./definitions/args";
import {
  InputDefinitionBlock,
  NexusInputFieldDef,
  NexusOutputFieldDef,
  OutputDefinitionBlock,
} from "./definitions/definitionBlocks";
import { EnumTypeConfig } from "./definitions/enumType";
import {
  NexusExtendTypeConfig,
  NexusExtendTypeDef,
} from "./definitions/extendType";
import { NexusInputObjectTypeConfig } from "./definitions/inputObjectType";
import {
  NexusInterfaceTypeConfig,
  NexusInterfaceTypeDef,
} from "./definitions/interfaceType";
import {
  NexusObjectTypeConfig,
  NexusObjectTypeDef,
  ObjectDefinitionBlock,
} from "./definitions/objectType";
import { NexusScalarTypeConfig } from "./definitions/scalarType";
import { NexusUnionTypeConfig, UnionMembers } from "./definitions/unionType";
import {
  AllNexusInputTypeDefs,
  AllNexusNamedTypeDefs,
  NexusWrappedType,
  AllNexusOutputTypeDefs,
} from "./definitions/wrapping";
import {
  GraphQLPossibleInputs,
  GraphQLPossibleOutputs,
  NonNullConfig,
  RootTypings,
} from "./definitions/_types";
import { TypegenAutoConfigOptions } from "./typegenAutoConfig";
import { TypegenFormatFn } from "./typegenFormatPrettier";
import { GetGen, AuthorizeResolver } from "./typegenTypeHelpers";
import {
  NexusExtendInputTypeDef,
  NexusExtendInputTypeConfig,
} from "./definitions/extendInputType";
import { DynamicInputMethodDef, DynamicOutputMethodDef } from "./dynamicMethod";
export declare type Maybe<T> = T | null;
declare type NexusShapedOutput = {
  name: string;
  definition: (t: ObjectDefinitionBlock<string>) => void;
};
declare type NexusShapedInput = {
  name: string;
  definition: (t: InputDefinitionBlock<string>) => void;
};
export interface BuilderConfig {
  /**
   * When the schema starts and `process.env.NODE_ENV !== "production"`,
   * artifact files are auto-generated containing the .graphql definitions of
   * the schema
   */
  outputs:
    | {
        /**
         * Absolute path where the GraphQL IDL file should be written
         */
        schema: string | false;
        /**
         * File path where generated types should be saved
         */
        typegen: string | false;
      }
    | false;
  /**
   * Whether the schema & types are generated when the server
   * starts. Default is !process.env.NODE_ENV || process.env.NODE_ENV === "development"
   */
  shouldGenerateArtifacts?: boolean;
  /**
   * Automatically configure type resolution for the TypeScript
   * representations of the associated types.
   *
   * Alias for typegenConfig: typegenAutoConfig(options)
   */
  typegenAutoConfig?: TypegenAutoConfigOptions;
  /**
   * A configuration function for advanced cases where
   * more control over the `TypegenInfo` is needed.
   */
  typegenConfig?: (
    schema: GraphQLSchema,
    outputPath: string
  ) => TypegenInfo | PromiseLike<TypegenInfo>;
  /**
   * Either an absolute path to a .prettierrc file, or an object
   * with relevant Prettier rules to be used on the generated output
   */
  prettierConfig?: string | object;
  /**
   * Manually apply a formatter to the generated content before saving,
   * see the `prettierConfig` option if you want to use Prettier.
   */
  formatTypegen?: TypegenFormatFn;
  /**
   * Configures the default "nonNullDefaults" for the entire schema the type.
   * Read more about how nexus handles nullability
   */
  nonNullDefaults?: NonNullConfig;
}
export interface TypegenInfo {
  /**
   * Headers attached to the generate type output
   */
  headers: string[];
  /**
   * All imports for the backing types / context
   */
  imports: string[];
  /**
   * A map of all GraphQL types and what TypeScript types they should
   * be represented by.
   */
  backingTypeMap: { [K in GetGen<"objectNames">]?: string };
  /**
   * The type of the context for the resolvers
   */
  contextType?: string;
}
export interface SchemaConfig extends BuilderConfig {
  /**
   * All of the GraphQL types. This is an any for simplicity of developer experience,
   * if it's an object we get the values, if it's an array we flatten out the
   * valid types, ignoring invalid ones.
   */
  types: any;
}
export declare type TypeToWalk =
  | {
      type: "named";
      value: GraphQLNamedType;
    }
  | {
      type: "input";
      value: NexusShapedInput;
    }
  | {
      type: "object";
      value: NexusShapedOutput;
    }
  | {
      type: "interface";
      value: NexusInterfaceTypeConfig<any>;
    };
export declare type DynamicInputFields = Record<
  string,
  DynamicInputMethodDef<string> | string
>;
export declare type DynamicOutputFields = Record<
  string,
  DynamicOutputMethodDef<string> | string
>;
/**
 * Builds all of the types, properly accounts for any using "mix".
 * Since the enum types are resolved synchronously, these need to guard for
 * circular references at this step, while fields will guard for it during lazy evaluation.
 */
export declare class SchemaBuilder {
  protected config: BuilderConfig;
  /**
   * Used to check for circular references.
   */
  protected buildingTypes: Set<any>;
  /**
   * The "final type" map contains all types as they are built.
   */
  protected finalTypeMap: Record<string, GraphQLNamedType>;
  /**
   * The "defined type" map keeps track of all of the types that were
   * defined directly as `GraphQL*Type` objects, so we don't accidentally
   * overwrite any.
   */
  protected definedTypeMap: Record<string, GraphQLNamedType>;
  /**
   * The "pending type" map keeps track of all types that were defined w/
   * GraphQL Nexus and haven't been processed into concrete types yet.
   */
  protected pendingTypeMap: Record<string, AllNexusNamedTypeDefs>;
  /**
   * All "extensions" to types (adding fields on types from many locations)
   */
  protected typeExtensionMap: Record<
    string,
    NexusExtendTypeConfig<string>[] | null
  >;
  /**
   * All "extensions" to input types (adding fields on types from many locations)
   */
  protected inputTypeExtensionMap: Record<
    string,
    NexusExtendInputTypeConfig<string>[] | null
  >;
  /**
   * Configures the root-level nonNullDefaults defaults
   */
  protected nonNullDefaults: NonNullConfig;
  /**
   * Add dynamic input fields
   */
  protected dynamicInputFields: DynamicInputFields;
  /**
   * Add dynamic output fields
   */
  protected dynamicOutputFields: DynamicOutputFields;
  /**
   * All types that need to be traversed for children types
   */
  protected typesToWalk: TypeToWalk[];
  /**
   * Root type mapping information annotated on the type definitions
   */
  protected rootTypings: RootTypings;
  /**
   * Whether we've called `getFinalTypeMap` or not
   */
  protected finalized: boolean;
  constructor(config: BuilderConfig);
  getConfig(): BuilderConfig;
  /**
   * Add type takes a Nexus type, or a GraphQL type and pulls
   * it into an internal "type registry". It also does an initial pass
   * on any types that are referenced on the "types" field and pulls
   * those in too, so you can define types anonymously, without
   * exporting them.
   *
   * @param typeDef
   */
  addType(
    typeDef:
      | AllNexusNamedTypeDefs
      | NexusExtendInputTypeDef<string>
      | NexusExtendTypeDef<string>
      | GraphQLNamedType
      | DynamicInputMethodDef<string>
      | DynamicOutputMethodDef<string>
  ): void;
  walkTypes(): void;
  getFinalTypeMap(): BuildTypes<any>;
  buildInputObjectType(
    config: NexusInputObjectTypeConfig<any>
  ): GraphQLInputObjectType;
  buildObjectType(
    config: NexusObjectTypeConfig<any>
  ): GraphQLObjectType<
    any,
    any,
    {
      [key: string]: any;
    }
  >;
  buildInterfaceType(
    config: NexusInterfaceTypeConfig<any>
  ): GraphQLInterfaceType;
  buildEnumType(config: EnumTypeConfig<any>): GraphQLEnumType;
  buildUnionType(config: NexusUnionTypeConfig<any>): GraphQLUnionType;
  buildScalarType(config: NexusScalarTypeConfig<string>): GraphQLScalarType;
  protected finalize<T extends GraphQLNamedType>(type: T): T;
  protected missingType(
    typeName: string,
    fromObject?: boolean
  ): GraphQLNamedType;
  protected buildUnionMembers(
    unionName: string,
    members: UnionMembers | undefined
  ): GraphQLObjectType<
    any,
    any,
    {
      [key: string]: any;
    }
  >[];
  protected buildObjectFields(
    fields: NexusOutputFieldDef[],
    typeConfig: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>,
    intoObject: GraphQLFieldConfigMap<any, any>,
    forInterface?: boolean
  ): GraphQLFieldConfigMap<any, any>;
  protected buildInputObjectFields(
    fields: NexusInputFieldDef[],
    typeConfig: NexusInputObjectTypeConfig<string>
  ): GraphQLInputFieldConfigMap;
  protected buildObjectField(
    fieldConfig: NexusOutputFieldDef,
    typeConfig:
      | NexusObjectTypeConfig<string>
      | NexusInterfaceTypeConfig<string>,
    forInterface?: boolean
  ): GraphQLFieldConfig<any, any>;
  protected buildInputObjectField(
    field: NexusInputFieldDef,
    typeConfig: NexusInputObjectTypeConfig<any>
  ): GraphQLInputFieldConfig;
  protected buildArgs(
    args: ArgsRecord,
    typeConfig: NexusObjectTypeConfig<string> | NexusInterfaceTypeConfig<string>
  ): GraphQLFieldConfigArgumentMap;
  protected inputNonNull(
    typeDef:
      | NexusObjectTypeConfig<any>
      | NexusInterfaceTypeConfig<any>
      | NexusInputObjectTypeConfig<any>,
    field: NexusInputFieldDef | NexusArgConfig<any>
  ): boolean;
  protected outputNonNull(
    typeDef: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>,
    field: NexusOutputFieldDef
  ): boolean;
  protected decorateType<T extends GraphQLNamedType>(
    type: T,
    list: null | undefined | true | boolean[],
    isNonNull: boolean
  ): T;
  protected decorateList<T extends GraphQLOutputType | GraphQLInputType>(
    type: T,
    list: true | boolean[]
  ): T;
  protected getInterface(
    name: string | NexusInterfaceTypeDef<string>
  ): GraphQLInterfaceType;
  protected getEnum(name: string): GraphQLEnumType;
  protected getUnion(name: string): GraphQLUnionType;
  protected getInputObjectType(name: string): GraphQLInputObjectType;
  protected getInputType(
    name:
      | string
      | AllNexusInputTypeDefs
      | NexusWrappedType<AllNexusInputTypeDefs>
  ): GraphQLPossibleInputs;
  protected getOutputType(
    name: string | AllNexusOutputTypeDefs | NexusWrappedType<any>
  ): GraphQLPossibleOutputs;
  protected getObjectType(
    name: string | NexusObjectTypeDef<string>
  ): GraphQLObjectType;
  protected getOrBuildType(
    name:
      | string
      | AllNexusNamedTypeDefs
      | NexusWrappedType<AllNexusNamedTypeDefs>,
    fromObject?: boolean
  ): GraphQLNamedType;
  protected getSubscribe(
    fieldConfig: NexusOutputFieldDef
  ):
    | GraphQLFieldResolver<
        any,
        any,
        {
          [argName: string]: any;
        }
      >
    | undefined;
  protected getResolver(
    fieldConfig: NexusOutputFieldDef,
    typeConfig: NexusObjectTypeConfig<any> | NexusInterfaceTypeConfig<any>,
    forInterface?: boolean
  ):
    | GraphQLFieldResolver<
        any,
        any,
        {
          [argName: string]: any;
        }
      >
    | undefined;
  missingResolveType(name: string, location: "union" | "interface"): () => null;
  protected walkInputType<T extends NexusShapedInput>(obj: T): T;
  addDynamicInputFields(
    block: InputDefinitionBlock<any>,
    isList: boolean
  ): void;
  addDynamicOutputFields(
    block: OutputDefinitionBlock<any>,
    isList: boolean
  ): void;
  addDynamicScalar(
    methodName: string,
    typeName: string,
    block: OutputDefinitionBlock<any> | InputDefinitionBlock<any>
  ): void;
  protected walkOutputType<T extends NexusShapedOutput>(obj: T): T;
  protected walkInterfaceType(
    obj: NexusInterfaceTypeConfig<any>
  ): NexusInterfaceTypeConfig<any>;
  protected maybeTraverseOutputType(type: NexusOutputFieldDef): void;
  protected maybeTraverseInputType(type: NexusInputFieldDef): void;
  protected walkNamedTypes(namedType: GraphQLNamedType): void;
  protected addObjectField(obj: GraphQLField<any, any>): void;
}
export declare function wrapAuthorize(
  resolver: GraphQLFieldResolver<any, any>,
  authorize: AuthorizeResolver<string, any>
): GraphQLFieldResolver<any, any>;
export declare type DynamicFieldDefs = {
  dynamicInputFields: DynamicInputFields;
  dynamicOutputFields: DynamicOutputFields;
};
export interface BuildTypes<
  TypeMapDefs extends Record<string, GraphQLNamedType>
> {
  typeMap: TypeMapDefs;
  dynamicFields: DynamicFieldDefs;
  rootTypings: RootTypings;
}
/**
 * Builds the types, normalizing the "types" passed into the schema for a
 * better developer experience. This is primarily useful for testing
 * type generation
 */
export declare function buildTypes<
  TypeMapDefs extends Record<string, GraphQLNamedType> = any
>(
  types: any,
  config?: BuilderConfig,
  schemaBuilder?: SchemaBuilder
): BuildTypes<TypeMapDefs>;
export declare type NexusSchemaExtensions = {
  rootTypings: RootTypings;
  dynamicFields: DynamicFieldDefs;
};
export declare type NexusSchema = GraphQLSchema & {
  extensions: Record<string, any> & {
    nexus: NexusSchemaExtensions;
  };
};
/**
 * Builds the schema, we may return more than just the schema
 * from this one day.
 */
export declare function makeSchemaInternal(
  options: SchemaConfig,
  schemaBuilder?: SchemaBuilder
): {
  schema: NexusSchema;
};
/**
 * Defines the GraphQL schema, by combining the GraphQL types defined
 * by the GraphQL Nexus layer or any manually defined GraphQLType objects.
 *
 * Requires at least one type be named "Query", which will be used as the
 * root query type.
 */
export declare function makeSchema(options: SchemaConfig): NexusSchema;
export {};
