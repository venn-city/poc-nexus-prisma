"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var graphql_2 = require("./graphql");
var throw_1 = require("./throw");
var utils_1 = require("./utils");
var camelcase_1 = require("./camelcase");
function shouldRelyOnDefaultResolver(typeName, fieldToResolve, datamodelInfo) {
    var fieldName = fieldToResolve.name;
    var finalType = graphql_2.getFinalType(fieldToResolve.type);
    if (graphql_1.isScalarType(finalType)) {
        return true;
    }
    if (graphql_1.isEnumType(finalType)) {
        return true;
    }
    // Embedded types are handled just like scalars
    if (datamodelInfo.embeddedTypes.includes(typeName)) {
        return true;
    }
    if (utils_1.isConnectionTypeName(typeName) && fieldName !== 'aggregate') {
        // returns `pageInfo` and `edges` queries by the client
        return true;
    }
    if (utils_1.isSubscriptionType(typeName)) {
        return true;
    }
    // fields inside `edges` are queried as well, we can simply return them
    if (typeName.endsWith('Edge') &&
        typeName !== 'Edge' &&
        (fieldName === 'node' || fieldName === 'cursor')) {
        return true;
    }
    return false;
}
exports.shouldRelyOnDefaultResolver = shouldRelyOnDefaultResolver;
function getPrismaClient(prismaClient, ctx) {
    if (typeof prismaClient === 'function') {
        return prismaClient(ctx);
    }
    return prismaClient;
}
function generateDefaultResolver(typeName, fieldToResolve, prismaClientInput, datamodelInfo) {
    var fieldName = fieldToResolve.name;
    /**
     * If we know the prisma-client returns these fields, then let's just return undefined and let nexus handle it with a default resolver
     * We need to do this to make the typings working without having to provide a typegenAutoconfig.source to the the prisma-client
     * becase Nexus does not generate types from the schema for fields that have a resolve property
     */
    if (shouldRelyOnDefaultResolver(typeName, fieldToResolve, datamodelInfo)) {
        return undefined;
    }
    var isTopLevel = ['Query', 'Mutation', 'Subscription'].includes(typeName);
    var parentName = camelcase_1.camelCase(typeName);
    if (typeName === 'Subscription') {
        throw new Error('Subscription are not supported yet');
    }
    return function (root, args, ctx, info) {
        var _a;
        var prismaClient = getPrismaClient(prismaClientInput, ctx);
        // Resolve top-level fields
        if (isTopLevel) {
            throw_1.throwIfUnknownClientFunction(prismaClient, fieldName, typeName, info);
            if (utils_1.isCreateMutation(typeName, fieldName)) {
                args = args.data;
            }
            else if (utils_1.isDeleteMutation(typeName, fieldName)) {
                args = args.where;
            }
            else if (
            // If is "findOne" query (eg: `user`, or `post`)
            utils_1.isNotArrayOrConnectionType(fieldToResolve) &&
                (typeName !== 'Node' && fieldName !== 'node') &&
                typeName !== 'Mutation') {
                args = args.where;
            }
            return prismaClient[fieldName](args);
        }
        throw_1.throwIfUnknownClientFunction(prismaClient, parentName, typeName, info);
        var uniqFieldName = datamodelInfo.uniqueFieldsByModel[typeName].find(function (uniqFieldName) { return root[uniqFieldName] !== undefined; });
        throw_1.throwIfNoUniqFieldName(uniqFieldName, parentName);
        return prismaClient[parentName]((_a = {},
            _a[uniqFieldName] = root[uniqFieldName],
            _a))[fieldName](args);
    };
}
exports.generateDefaultResolver = generateDefaultResolver;
//# sourceMappingURL=resolver.js.map