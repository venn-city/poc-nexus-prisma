"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("./graphql");
var throw_1 = require("./throw");
function getAllFields(typeName, schema) {
    return Object.keys(graphql_1.findObjectType(typeName, schema).getFields()).map(function (fieldName) {
        return ({
            name: fieldName,
        });
    });
}
exports.getAllFields = getAllFields;
function getFields(inputFields, typeName, schema) {
    var fields = extractFields(inputFields, typeName, schema);
    var normalizedFields = normalizeFields(fields);
    var objectType = graphql_1.findObjectType(typeName, schema);
    // Make sure all the fields exists
    throw_1.throwIfUnknownFields(objectType, normalizedFields, typeName);
    return normalizedFields;
}
exports.getFields = getFields;
function isPickInputField(arg) {
    return (arg.pick !==
        undefined);
}
function allOrInputFields(fields, prismaFieldsNames) {
    var hasWhitelist = fields.filter(function (f) { return typeof f === 'string'; }).includes('*');
    return hasWhitelist ? prismaFieldsNames : fields;
}
function extractFields(fields, typeName, schema) {
    var prismaFieldsNames = getAllFields(typeName, schema).map(function (f) { return f.name; });
    // TODO: Remove that once `node` is removed from the Prisma API
    if (typeName === 'Query') {
        prismaFieldsNames = prismaFieldsNames.filter(function (field) { return field !== 'node'; });
    }
    if (Array.isArray(fields)) {
        return allOrInputFields(fields, prismaFieldsNames);
    }
    if (isPickInputField(fields)) {
        return allOrInputFields(fields.pick, prismaFieldsNames);
    }
    if (Array.isArray(fields.filter)) {
        var fieldsToFilter = fields.filter;
        var fieldsNamesToFilter_1 = fieldsToFilter.map(function (f) {
            return typeof f === 'string' ? f : f.name;
        });
        if (fieldsNamesToFilter_1.includes('*')) {
            return [];
        }
        return prismaFieldsNames.filter(function (fieldName) { return !fieldsNamesToFilter_1.includes(fieldName); });
    }
    else {
        return fields.filter(prismaFieldsNames);
    }
}
function normalizeFields(fields) {
    return fields.map(function (f) {
        if (typeof f === 'string') {
            return {
                name: f,
            };
        }
        return f;
    });
}
exports.normalizeFields = normalizeFields;
function isDeleteMutation(typeName, fieldName) {
    return (typeName === 'Mutation' &&
        fieldName.startsWith('delete') &&
        fieldName !== 'delete');
}
exports.isDeleteMutation = isDeleteMutation;
function isCreateMutation(typeName, fieldName) {
    return (typeName === 'Mutation' &&
        fieldName.startsWith('create') &&
        fieldName !== 'create');
}
exports.isCreateMutation = isCreateMutation;
function isNotArrayOrConnectionType(fieldToResolve) {
    return (!graphql_1.isList(fieldToResolve.type) &&
        !isConnectionTypeName(graphql_1.getTypeName(fieldToResolve.type)));
}
exports.isNotArrayOrConnectionType = isNotArrayOrConnectionType;
function isConnectionTypeName(typeName) {
    return typeName.endsWith('Connection') && typeName !== 'Connection';
}
exports.isConnectionTypeName = isConnectionTypeName;
function isSubscriptionType(typeName) {
    // *SubscriptionPayload
    return (typeName.endsWith('SubscriptionPayload') &&
        typeName !== 'SubscriptionPayload');
}
exports.isSubscriptionType = isSubscriptionType;
function flatMap(array, callbackfn) {
    var _a;
    return (_a = Array.prototype).concat.apply(_a, array.map(callbackfn));
}
exports.flatMap = flatMap;
function whitelistArgs(args, whitelist) {
    if (whitelist === false ||
        (Array.isArray(whitelist) && whitelist.length === 0)) {
        return undefined;
    }
    if (whitelist === undefined) {
        return args;
    }
    return Object.keys(args).reduce(function (acc, argName) {
        var _a;
        if (whitelist.includes(argName)) {
            return __assign({}, acc, (_a = {}, _a[argName] = args[argName], _a));
        }
        return acc;
    }, {});
}
exports.whitelistArgs = whitelistArgs;
//# sourceMappingURL=utils.js.map